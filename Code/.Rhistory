### Bright and Taylor - Algorithm 1
# We truncate the QBD at M levels and then recursively
# obtain all of the rate matrices R_k, k is between 0 and M
# 1. Calculate R_{M-1}
# Algorithm 2 implementation
l <- 0; k <- M-1; UD0 <- list(); UD <- list(list());
UD0[[k]] <- get_U_D_ij(0,k,A0,A1,A2,UD0,UD)
Rk <- UD0[[k]][,,1]
D <- UD0[[k]][,,2]
Pi_D <- I
eps <- 10^-7; mRk <- eps;
while(mRk>=eps){
Pi_D <- D%*%Pi_D
#### Algorithm 3 Implementation #####
for (i in 0:l){
for (j in seq((k+(2^(l-i+1)-1)*2^i), (k+(2^(l-i+1)-1)*2^(i+1)), 2^i)){
# Obtain UD(i,j):
if (i==0){
UD0[[j]] <- get_U_D_ij(0,j,A0,A1,A2,UD0,UD)
}else{
UD[[i]][[j]] <- get_U_D_ij(i,j,A0,A1,A2,UD0,UD)
}
}
}
# Obtain UD(l,k):
l <- l+1
UD <- append(UD, list(list()))
UD[[l]][[k]] <- get_U_D_ij(l,k,A0,A1,A2,UD0,UD)
U <- UD[[l]][[k]][,,1]
D <- UD[[l]][[k]][,,2]
delta_Rk <- U%*%Pi_D
Rk <- Rk + delta_Rk
mRk <- max(delta_Rk)
}
R <- array(NA, dim=c(block_size, block_size, k))
R[,,k] <- Rk
for (rk in (M-2):1){
inv_term <- solve(-A1[,,(rk+1)]-R[,,(rk+1)]%*%A2[,,(rk+2)])
R[,,rk] <- A0%*%inv_term
}
inv_term <- solve(-A1[,,1]-R[,,1]%*%A2[,,2])
R0 <- A0%*%inv_term
# 3. Solve for the initial probability vector p0
# This entails solving Pi_0*U_0 = 0
BpRA <- cbind(A1_0+R0%*%A2[,,1], rep(1,block_size))
b <- c(rep(0,block_size),1)
pi_list0 <- b%*%ginv(BpRA)
# Work back up to M to find all of the limiting probs
pi_list <- matrix(NA, nrow=M, ncol=3*re_size)
pi_list[1,] <- pi_list0%*%R0
for (j in 2:M){
pi_list[j,] <- pi_list[(j-1),]%*%R[,,(j-1)]
sum_probs <- sum(pi_list0) + sum(pi_list[1:j,])
pi_list0 <- pi_list0 / sum_probs
pi_list <- pi_list / sum_probs
}
# Compute stability condition rho (need to adjust)
D_alpha <- Q_re - d_alpha - d_xi
rho_num <- -e_re%*%((Q_re-d_alpha)%*%d_xi + D_alpha%*%d_lam)%*%
solve(D_alpha)%*%e_re
rho_denom <- e_re%*%(Q_re-d_alpha)%*%(Q_re-d_mu-d_xi)%*%solve(D_alpha)%*%e_re;
rho <- rho_num / rho_denom
# Sum up limiting probs to obtain limiting orbit size probs
pi_orb0 <- sum(pi_list0)
L_R <- 0
idle_prob <- sum(pi_list0[1:re_size])
broke_prob <- sum(pi_list0[(re_size+1):(2*re_size)])
busy_prob <- sum(pi_list0[(2*re_size+1):block_size])
pi_orb <- rep(0, M*block_size)
for (i in 1:M){
pi_orb[i] <- sum(pi_list[i,])
L_R <- L_R + i*pi_orb[i]
idle_prob <- idle_prob + sum(pi_list[i,1:re_size])
broke_prob <- broke_prob + sum(pi_list[i,(re_size+1):(2*re_size)])
busy_prob = busy_prob + sum(pi_list[i,(2*re_size+1):block_size])
}
# L_R is the expected number in the orbit
# L is expected number in the system
L <- L_R + busy_prob
# Compute sojourn times
lambda_ave <- sum(p_re*lambda)
W_R <- L_R/lambda_ave
W <- L/lambda_ave
####### Output Section #########
level <- c(0,cumsum(rep(1, block_size*M)))
pi_list_vert <- c()
pi_orb_vert <- c(pi_orb0, pi_orb)
for (i in 1:M){
pi_list_vert <- c(pi_list_vert, pi_list[i,])
}
# The distributions at equilibrium for the M/M/1/1 retrial queue
# in a random environment is stored in the matrix a
E_distribution <- list()
a <- cbind(level[1:(block_size*M)],
pi_list_vert[1:(block_size*M)],
pi_orb_vert[1:(M*block_size)])
colnames(a) <- c("n", "p_n", "p_orb_n")
E_distribution$dist <- as.data.frame(a)
E_distribution$rho <- rho
E_distribution$P_idle <- idle_prob
E_distribution$P_broke <- broke_prob
E_distribution$P_busy <- busy_prob
E_distribution$E_R <- L_R
E_distribution$E_L <- L
E_distribution$E_W_R <- W_R
E_distribution$E_W <- W
#### plot results ####
par(mar = c(5, 5, 4, 2))
plot(level[1:M+1],pi_orb_vert[1:M+1], lwd=3, type="l", main="Eq Probs for Orbit, 3-State R.E.",
xlab="No. in Orbit", ylab="Probability", cex.lab=2, cex.axis=2, cex.main=2)
arrows(x0=which.max(pi_orb_vert[1:M+1])+7, x1=which.max(pi_orb_vert[1:M+1])+2, y0=(max(pi_orb_vert[1:M+1])-0.001), y1=max(pi_orb_vert[1:M+1]), length=0.2, lwd=2)
text((which.max(pi_orb_vert[1:M+1])+25), (max(pi_orb_vert[1:M+1])-0.001), paste("Pmax =", round(max(pi_orb_vert[1:M+1]),6)), cex=2)
text((which.max(pi_orb_vert[1:M+1])+25), (max(pi_orb_vert[1:M+1])-0.005), paste("No. in Orbit =", which.max(pi_orb_vert[1:M+1])), cex=2)
rho
# Initilization
#cat("\014") # Clear the console
rm(list=ls())
graphics.off()
##### import necessary packages and functions
library(MASS)
source("C:/Users/Tessa/Dropbox/Inventory project/Code/All_functions.R")
######
# The algorithm included in this file solves for the equilibrium probabilities
# of the M/M/1-based unreliable retrial queue in a Markovian environment using
# the algorithms of Bright & Taylor
# The matrices that comprise Q* are initialized in the
# Definitions section below
######
############ Definitions ##############
lambda <- c(1, 0.1, 3) # Arrival reates - 3-State
# lambda <- rep(0.5, 3) # Plain Retrial
#lambda <- c(3, 1, 3, 2, 2, 0.5, 0.5) # 7-State
mu <- c(0.5, 0.8, 10) # Service rates - 3 state
# mu <- rep(0.8, 3) # Plain Retrial
#mu <- c(7, 3, 8, 10, 4.5, 2, 4)
alpha <- c(4, 7, 2) # Repair rates - 3-State
#alpha <- c(2, 7, 15, 2, 5, 3, 0.5)
theta <- c(1.5, 3, 5) # Plain Retrial - 3-State
#theta <- c(1, 11, 2, 2, 5, 1, 0.5)
xi <- c(9, 2, 0.1) # Failure rates - 3-State
#xi <- c(0.5, 1.1, 1.5, 3, 1, 0.7, 1.5) # 7-State
# Components of the random environment
# Generator matrix
Q_re <- matrix(c(-1, 1, 0, 1.6, -2.6, 1, 0, 3.2, -3.2), ncol=3, byrow=T)
#Q_re <- matrix(c(-11.81, 5, 6, 0.5, 0.01, 0.1, 0.2,
#                 0.05, -12.17, 8, 3, 0.3, 0.8, 0.02,
#                 0.3, 1.5, -2.855, 0.5, 0.5, 0.05, 0.005,
#                 0.01, 3, 5, -9.21, 0.1, 1, 0.1,
#                 0.08, 2.5, 2, 0.1, -4.469, 0.004, 0.01,
#                 1.5, 25, 35, 1.2, 0.5, -63.7, 0.5,
#                 1, 2.5, 2, 1, 0.8, 0.9, -8.2), ncol=7, byrow=T)
index <- 2
if (index!=0){
lambda <- lambda[index]
mu <- mu[index]
xi <- xi[index]
alpha <- alpha[index]
theta <- theta[index]
Q_re <- Q_re[index,index]
}
# Size of the random environment and QBD blocks
re_size <- length(lambda)
block_size <- 3*re_size
# Find the limiting probabilities of the random environment.
# This will allow us to compute the queue length at equilibrium
e_re <- rep(1, re_size)
Q_syseqns <- unname(cbind(Q_re, e_re))
b_Q <- c(0*e_re, 1)
p_re <- b_Q%*%ginv(Q_syseqns)
M <- 75 # Levels of Q* matrix that we consider
L <- 9
M_star <- M+2^(L+2) # Actual number of levels in Q*
I <-  diag(block_size)
# QBD Block Definitions
Z <- matrix(0, ncol=re_size, nrow=re_size)
d_lam <- lambda*diag(re_size)
d_mu <- mu*diag(re_size)
d_alpha <- alpha*diag(re_size)
d_xi <- xi*diag(re_size)
d_theta <- theta*diag(re_size)
Q1 <- Q_re - d_lam - d_mu - d_xi
Q2 <- Q_re - d_alpha - d_lam
Q0 <- d_mu + Q1
A0 <- rbind(cbind(Z, Z, Z), cbind(Z, d_lam, Z), cbind(Z, d_xi, d_lam))
A1_0 <- rbind(cbind(Q0, d_xi, d_lam), cbind(d_alpha, Q2, Z), cbind(d_mu, Z, Q1))
### Making blocks
A1 <- array(NA, dim=c(block_size, block_size, M_star))
A2 <- array(NA, dim=c(block_size, block_size, M_star))
for (i in 1:M_star){
d_theta_i <- d_theta*i
Qi <- Q0-d_theta_i
A1[,,i] <- rbind(cbind(Qi, d_xi, d_lam), cbind(d_alpha, Q2, Z), cbind(d_mu, Z, Q1))
A2[,,i] <- rbind(cbind(Z,Z,d_theta_i), cbind(Z,Z,Z), cbind(Z, Z, Z))
}
### Bright and Taylor - Algorithm 1
# We truncate the QBD at M levels and then recursively
# obtain all of the rate matrices R_k, k is between 0 and M
# 1. Calculate R_{M-1}
# Algorithm 2 implementation
l <- 0; k <- M-1; UD0 <- list(); UD <- list(list());
UD0[[k]] <- get_U_D_ij(0,k,A0,A1,A2,UD0,UD)
Rk <- UD0[[k]][,,1]
D <- UD0[[k]][,,2]
Pi_D <- I
eps <- 10^-7; mRk <- eps;
while(mRk>=eps){
Pi_D <- D%*%Pi_D
#### Algorithm 3 Implementation #####
for (i in 0:l){
for (j in seq((k+(2^(l-i+1)-1)*2^i), (k+(2^(l-i+1)-1)*2^(i+1)), 2^i)){
# Obtain UD(i,j):
if (i==0){
UD0[[j]] <- get_U_D_ij(0,j,A0,A1,A2,UD0,UD)
}else{
UD[[i]][[j]] <- get_U_D_ij(i,j,A0,A1,A2,UD0,UD)
}
}
}
# Obtain UD(l,k):
l <- l+1
UD <- append(UD, list(list()))
UD[[l]][[k]] <- get_U_D_ij(l,k,A0,A1,A2,UD0,UD)
U <- UD[[l]][[k]][,,1]
D <- UD[[l]][[k]][,,2]
delta_Rk <- U%*%Pi_D
Rk <- Rk + delta_Rk
mRk <- max(delta_Rk)
}
R <- array(NA, dim=c(block_size, block_size, k))
R[,,k] <- Rk
for (rk in (M-2):1){
inv_term <- solve(-A1[,,(rk+1)]-R[,,(rk+1)]%*%A2[,,(rk+2)])
R[,,rk] <- A0%*%inv_term
}
inv_term <- solve(-A1[,,1]-R[,,1]%*%A2[,,2])
R0 <- A0%*%inv_term
# 3. Solve for the initial probability vector p0
# This entails solving Pi_0*U_0 = 0
BpRA <- cbind(A1_0+R0%*%A2[,,1], rep(1,block_size))
b <- c(rep(0,block_size),1)
pi_list0 <- b%*%ginv(BpRA)
# Work back up to M to find all of the limiting probs
pi_list <- matrix(NA, nrow=M, ncol=3*re_size)
pi_list[1,] <- pi_list0%*%R0
for (j in 2:M){
pi_list[j,] <- pi_list[(j-1),]%*%R[,,(j-1)]
sum_probs <- sum(pi_list0) + sum(pi_list[1:j,])
pi_list0 <- pi_list0 / sum_probs
pi_list <- pi_list / sum_probs
}
# Compute stability condition rho (need to adjust)
D_alpha <- Q_re - d_alpha - d_xi
rho_num <- -e_re%*%((Q_re-d_alpha)%*%d_xi + D_alpha%*%d_lam)%*%
solve(D_alpha)%*%e_re
rho_denom <- e_re%*%(Q_re-d_alpha)%*%(Q_re-d_mu-d_xi)%*%solve(D_alpha)%*%e_re;
rho <- rho_num / rho_denom
# Sum up limiting probs to obtain limiting orbit size probs
pi_orb0 <- sum(pi_list0)
L_R <- 0
idle_prob <- sum(pi_list0[1:re_size])
broke_prob <- sum(pi_list0[(re_size+1):(2*re_size)])
busy_prob <- sum(pi_list0[(2*re_size+1):block_size])
pi_orb <- rep(0, M*block_size)
for (i in 1:M){
pi_orb[i] <- sum(pi_list[i,])
L_R <- L_R + i*pi_orb[i]
idle_prob <- idle_prob + sum(pi_list[i,1:re_size])
broke_prob <- broke_prob + sum(pi_list[i,(re_size+1):(2*re_size)])
busy_prob = busy_prob + sum(pi_list[i,(2*re_size+1):block_size])
}
# L_R is the expected number in the orbit
# L is expected number in the system
L <- L_R + busy_prob
# Compute sojourn times
lambda_ave <- sum(p_re*lambda)
W_R <- L_R/lambda_ave
W <- L/lambda_ave
####### Output Section #########
level <- c(0,cumsum(rep(1, block_size*M)))
pi_list_vert <- c()
pi_orb_vert <- c(pi_orb0, pi_orb)
for (i in 1:M){
pi_list_vert <- c(pi_list_vert, pi_list[i,])
}
# The distributions at equilibrium for the M/M/1/1 retrial queue
# in a random environment is stored in the matrix a
E_distribution <- list()
a <- cbind(level[1:(block_size*M)],
pi_list_vert[1:(block_size*M)],
pi_orb_vert[1:(M*block_size)])
colnames(a) <- c("n", "p_n", "p_orb_n")
E_distribution$dist <- as.data.frame(a)
E_distribution$rho <- rho
E_distribution$P_idle <- idle_prob
E_distribution$P_broke <- broke_prob
E_distribution$P_busy <- busy_prob
E_distribution$E_R <- L_R
E_distribution$E_L <- L
E_distribution$E_W_R <- W_R
E_distribution$E_W <- W
#### plot results ####
par(mar = c(5, 5, 4, 2))
plot(level[1:M+1],pi_orb_vert[1:M+1], lwd=3, type="l", main="Eq Probs for Orbit, 3-State R.E.",
xlab="No. in Orbit", ylab="Probability", cex.lab=2, cex.axis=2, cex.main=2)
arrows(x0=which.max(pi_orb_vert[1:M+1])+7, x1=which.max(pi_orb_vert[1:M+1])+2, y0=(max(pi_orb_vert[1:M+1])-0.001), y1=max(pi_orb_vert[1:M+1]), length=0.2, lwd=2)
text((which.max(pi_orb_vert[1:M+1])+25), (max(pi_orb_vert[1:M+1])-0.001), paste("Pmax =", round(max(pi_orb_vert[1:M+1]),6)), cex=2)
text((which.max(pi_orb_vert[1:M+1])+25), (max(pi_orb_vert[1:M+1])-0.005), paste("No. in Orbit =", which.max(pi_orb_vert[1:M+1])), cex=2)
rho
# Initilization
#cat("\014") # Clear the console
rm(list=ls())
graphics.off()
##### import necessary packages and functions
library(MASS)
source("C:/Users/Tessa/Dropbox/Inventory project/Code/All_functions.R")
######
# The algorithm included in this file solves for the equilibrium probabilities
# of the M/M/1-based unreliable retrial queue in a Markovian environment using
# the algorithms of Bright & Taylor
# The matrices that comprise Q* are initialized in the
# Definitions section below
######
############ Definitions ##############
lambda <- c(1, 0.1, 3) # Arrival reates - 3-State
# lambda <- rep(0.5, 3) # Plain Retrial
#lambda <- c(3, 1, 3, 2, 2, 0.5, 0.5) # 7-State
mu <- c(0.5, 0.8, 10) # Service rates - 3 state
# mu <- rep(0.8, 3) # Plain Retrial
#mu <- c(7, 3, 8, 10, 4.5, 2, 4)
alpha <- c(4, 7, 2) # Repair rates - 3-State
#alpha <- c(2, 7, 15, 2, 5, 3, 0.5)
theta <- c(1.5, 3, 5) # Plain Retrial - 3-State
#theta <- c(1, 11, 2, 2, 5, 1, 0.5)
xi <- c(9, 2, 0.1) # Failure rates - 3-State
#xi <- c(0.5, 1.1, 1.5, 3, 1, 0.7, 1.5) # 7-State
# Components of the random environment
# Generator matrix
Q_re <- matrix(c(-1, 1, 0, 1.6, -2.6, 1, 0, 3.2, -3.2), ncol=3, byrow=T)
#Q_re <- matrix(c(-11.81, 5, 6, 0.5, 0.01, 0.1, 0.2,
#                 0.05, -12.17, 8, 3, 0.3, 0.8, 0.02,
#                 0.3, 1.5, -2.855, 0.5, 0.5, 0.05, 0.005,
#                 0.01, 3, 5, -9.21, 0.1, 1, 0.1,
#                 0.08, 2.5, 2, 0.1, -4.469, 0.004, 0.01,
#                 1.5, 25, 35, 1.2, 0.5, -63.7, 0.5,
#                 1, 2.5, 2, 1, 0.8, 0.9, -8.2), ncol=7, byrow=T)
index <- 3
if (index!=0){
lambda <- lambda[index]
mu <- mu[index]
xi <- xi[index]
alpha <- alpha[index]
theta <- theta[index]
Q_re <- Q_re[index,index]
}
# Size of the random environment and QBD blocks
re_size <- length(lambda)
block_size <- 3*re_size
# Find the limiting probabilities of the random environment.
# This will allow us to compute the queue length at equilibrium
e_re <- rep(1, re_size)
Q_syseqns <- unname(cbind(Q_re, e_re))
b_Q <- c(0*e_re, 1)
p_re <- b_Q%*%ginv(Q_syseqns)
M <- 75 # Levels of Q* matrix that we consider
L <- 9
M_star <- M+2^(L+2) # Actual number of levels in Q*
I <-  diag(block_size)
# QBD Block Definitions
Z <- matrix(0, ncol=re_size, nrow=re_size)
d_lam <- lambda*diag(re_size)
d_mu <- mu*diag(re_size)
d_alpha <- alpha*diag(re_size)
d_xi <- xi*diag(re_size)
d_theta <- theta*diag(re_size)
Q1 <- Q_re - d_lam - d_mu - d_xi
Q2 <- Q_re - d_alpha - d_lam
Q0 <- d_mu + Q1
A0 <- rbind(cbind(Z, Z, Z), cbind(Z, d_lam, Z), cbind(Z, d_xi, d_lam))
A1_0 <- rbind(cbind(Q0, d_xi, d_lam), cbind(d_alpha, Q2, Z), cbind(d_mu, Z, Q1))
### Making blocks
A1 <- array(NA, dim=c(block_size, block_size, M_star))
A2 <- array(NA, dim=c(block_size, block_size, M_star))
for (i in 1:M_star){
d_theta_i <- d_theta*i
Qi <- Q0-d_theta_i
A1[,,i] <- rbind(cbind(Qi, d_xi, d_lam), cbind(d_alpha, Q2, Z), cbind(d_mu, Z, Q1))
A2[,,i] <- rbind(cbind(Z,Z,d_theta_i), cbind(Z,Z,Z), cbind(Z, Z, Z))
}
### Bright and Taylor - Algorithm 1
# We truncate the QBD at M levels and then recursively
# obtain all of the rate matrices R_k, k is between 0 and M
# 1. Calculate R_{M-1}
# Algorithm 2 implementation
l <- 0; k <- M-1; UD0 <- list(); UD <- list(list());
UD0[[k]] <- get_U_D_ij(0,k,A0,A1,A2,UD0,UD)
Rk <- UD0[[k]][,,1]
D <- UD0[[k]][,,2]
Pi_D <- I
eps <- 10^-7; mRk <- eps;
while(mRk>=eps){
Pi_D <- D%*%Pi_D
#### Algorithm 3 Implementation #####
for (i in 0:l){
for (j in seq((k+(2^(l-i+1)-1)*2^i), (k+(2^(l-i+1)-1)*2^(i+1)), 2^i)){
# Obtain UD(i,j):
if (i==0){
UD0[[j]] <- get_U_D_ij(0,j,A0,A1,A2,UD0,UD)
}else{
UD[[i]][[j]] <- get_U_D_ij(i,j,A0,A1,A2,UD0,UD)
}
}
}
# Obtain UD(l,k):
l <- l+1
UD <- append(UD, list(list()))
UD[[l]][[k]] <- get_U_D_ij(l,k,A0,A1,A2,UD0,UD)
U <- UD[[l]][[k]][,,1]
D <- UD[[l]][[k]][,,2]
delta_Rk <- U%*%Pi_D
Rk <- Rk + delta_Rk
mRk <- max(delta_Rk)
}
R <- array(NA, dim=c(block_size, block_size, k))
R[,,k] <- Rk
for (rk in (M-2):1){
inv_term <- solve(-A1[,,(rk+1)]-R[,,(rk+1)]%*%A2[,,(rk+2)])
R[,,rk] <- A0%*%inv_term
}
inv_term <- solve(-A1[,,1]-R[,,1]%*%A2[,,2])
R0 <- A0%*%inv_term
# 3. Solve for the initial probability vector p0
# This entails solving Pi_0*U_0 = 0
BpRA <- cbind(A1_0+R0%*%A2[,,1], rep(1,block_size))
b <- c(rep(0,block_size),1)
pi_list0 <- b%*%ginv(BpRA)
# Work back up to M to find all of the limiting probs
pi_list <- matrix(NA, nrow=M, ncol=3*re_size)
pi_list[1,] <- pi_list0%*%R0
for (j in 2:M){
pi_list[j,] <- pi_list[(j-1),]%*%R[,,(j-1)]
sum_probs <- sum(pi_list0) + sum(pi_list[1:j,])
pi_list0 <- pi_list0 / sum_probs
pi_list <- pi_list / sum_probs
}
# Compute stability condition rho (need to adjust)
D_alpha <- Q_re - d_alpha - d_xi
rho_num <- -e_re%*%((Q_re-d_alpha)%*%d_xi + D_alpha%*%d_lam)%*%
solve(D_alpha)%*%e_re
rho_denom <- e_re%*%(Q_re-d_alpha)%*%(Q_re-d_mu-d_xi)%*%solve(D_alpha)%*%e_re;
rho <- rho_num / rho_denom
# Sum up limiting probs to obtain limiting orbit size probs
pi_orb0 <- sum(pi_list0)
L_R <- 0
idle_prob <- sum(pi_list0[1:re_size])
broke_prob <- sum(pi_list0[(re_size+1):(2*re_size)])
busy_prob <- sum(pi_list0[(2*re_size+1):block_size])
pi_orb <- rep(0, M*block_size)
for (i in 1:M){
pi_orb[i] <- sum(pi_list[i,])
L_R <- L_R + i*pi_orb[i]
idle_prob <- idle_prob + sum(pi_list[i,1:re_size])
broke_prob <- broke_prob + sum(pi_list[i,(re_size+1):(2*re_size)])
busy_prob = busy_prob + sum(pi_list[i,(2*re_size+1):block_size])
}
# L_R is the expected number in the orbit
# L is expected number in the system
L <- L_R + busy_prob
# Compute sojourn times
lambda_ave <- sum(p_re*lambda)
W_R <- L_R/lambda_ave
W <- L/lambda_ave
####### Output Section #########
level <- c(0,cumsum(rep(1, block_size*M)))
pi_list_vert <- c()
pi_orb_vert <- c(pi_orb0, pi_orb)
for (i in 1:M){
pi_list_vert <- c(pi_list_vert, pi_list[i,])
}
# The distributions at equilibrium for the M/M/1/1 retrial queue
# in a random environment is stored in the matrix a
E_distribution <- list()
a <- cbind(level[1:(block_size*M)],
pi_list_vert[1:(block_size*M)],
pi_orb_vert[1:(M*block_size)])
colnames(a) <- c("n", "p_n", "p_orb_n")
E_distribution$dist <- as.data.frame(a)
E_distribution$rho <- rho
E_distribution$P_idle <- idle_prob
E_distribution$P_broke <- broke_prob
E_distribution$P_busy <- busy_prob
E_distribution$E_R <- L_R
E_distribution$E_L <- L
E_distribution$E_W_R <- W_R
E_distribution$E_W <- W
#### plot results ####
par(mar = c(5, 5, 4, 2))
plot(level[1:M+1],pi_orb_vert[1:M+1], lwd=3, type="l", main="Eq Probs for Orbit, 3-State R.E.",
xlab="No. in Orbit", ylab="Probability", cex.lab=2, cex.axis=2, cex.main=2)
arrows(x0=which.max(pi_orb_vert[1:M+1])+7, x1=which.max(pi_orb_vert[1:M+1])+2, y0=(max(pi_orb_vert[1:M+1])-0.001), y1=max(pi_orb_vert[1:M+1]), length=0.2, lwd=2)
text((which.max(pi_orb_vert[1:M+1])+25), (max(pi_orb_vert[1:M+1])-0.001), paste("Pmax =", round(max(pi_orb_vert[1:M+1]),6)), cex=2)
text((which.max(pi_orb_vert[1:M+1])+25), (max(pi_orb_vert[1:M+1])-0.005), paste("No. in Orbit =", which.max(pi_orb_vert[1:M+1])), cex=2)
rho
(0.2374205+1.12381+
0.3927469
)/3
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
pacman::p_load(tidyverse, magrittr, imbalance, ggtext, ggpubr, png)
alldata <- readRDS("../Data/results/all_datasets.RDS")
newthyroid2 <- alldata$data[[which(alldata$dataset=="new-thyroid2")]]
head(newthyroid2)
write_csv(newthyroid2, "newthyroid2.csv")
getwd()
